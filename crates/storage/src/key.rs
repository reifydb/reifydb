// Copyright (c) reifydb.com 2025
// This file is licensed under the AGPL-3.0-or-later

use crate::Key;
use regex::Regex;
use reifydb_core::AsyncCowVec;
use reifydb_core::encoding::binary::decode_binary;
use std::collections::Bound;
use std::ops::RangeBounds;

#[derive(Clone, Debug)]
pub struct KeyRange {
    start: Bound<Key>,
    end: Bound<Key>,
}

impl KeyRange {
    /// Generates a key range for a key prefix, used e.g. for prefix scans.
    ///
    /// The exclusive end bound is generated by adding 1 to the value of the last
    /// byte. If the last byte(s) is 0xff (so adding 1 would overflow), we instead
    /// find the latest non-0xff byte, increment that, and truncate the rest. If all
    /// bytes are 0xff, we scan to the end of the range, since there can't be other
    /// prefixes after it.
    pub fn prefix(prefix: &[u8]) -> Self {
        let start = Bound::Included(AsyncCowVec::new(prefix.to_vec()));
        let end = match prefix.iter().rposition(|&b| b != 0xff) {
            Some(i) => Bound::Excluded(AsyncCowVec::new(
                prefix.iter().take(i).copied().chain(std::iter::once(prefix[i] + 1)).collect(),
            )),
            None => Bound::Unbounded,
        };
        Self { start, end }
    }

    /// Constructs a key range from an optional inclusive start key to an optional exclusive end key.
    ///
    /// - `start`: If provided, marks the inclusive lower bound of the range. If `None`, the range is unbounded below.
    /// - `end`: If provided, marks the exclusive upper bound of the range. If `None`, the range is unbounded above.
    ///
    /// This function does not modify the input keys and assumes they are already exact keys
    /// (not prefixes). If you need to scan all keys with a given prefix, use [`KeyRange::prefix`] instead.
    ///
    /// Useful for scanning between two explicit keys in a sorted key-value store.
    pub fn start_end(start: Option<Key>, end: Option<Key>) -> Self {
        let start = match start {
            Some(s) => Bound::Included(s),
            None => Bound::Unbounded,
        };

        let end = match end {
            Some(e) => Bound::Excluded(e),
            None => Bound::Unbounded,
        };

        Self { start, end }
    }

    pub fn all() -> Self {
        Self { start: Bound::Unbounded, end: Bound::Unbounded }
    }

    pub fn parse(str: &str) -> Self {
        let (mut start, mut end) =
            (Bound::<AsyncCowVec<u8>>::Unbounded, Bound::<AsyncCowVec<u8>>::Unbounded);
        let re = Regex::new(r"^(\S+)?\.\.(=)?(\S+)?").expect("invalid regex");
        let groups = re.captures(str).ok_or_else(|| format!("invalid range {str}")).unwrap();
        if let Some(m) = groups.get(1) {
            start = Bound::Included(decode_binary(m.as_str()));
        }
        if let Some(m) = groups.get(3) {
            let decoded = decode_binary(m.as_str());
            if groups.get(2).is_some() {
                end = Bound::Included(decoded)
            } else {
                end = Bound::Excluded(decoded)
            }
        }
        Self { start, end }
    }
}

impl RangeBounds<Key> for KeyRange {
    fn start_bound(&self) -> Bound<&Key> {
        self.start.as_ref()
    }

    fn end_bound(&self) -> Bound<&Key> {
        self.end.as_ref()
    }
}
