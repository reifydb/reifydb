// Copyright (c) reifydb.com 2025
// This file is licensed under the AGPL-3.0-or-later

// #![cfg_attr(not(debug_assertions), deny(missing_docs))]
// #![cfg_attr(not(debug_assertions), deny(warnings))]
// #![cfg_attr(not(debug_assertions), deny(clippy::unwrap_used))]
// #![cfg_attr(not(debug_assertions), deny(clippy::expect_used))]

pub use error::Error;
pub use lmdb::{Lmdb, LmdbBatch};
pub use memory::{Memory, MemoryScanIter};
pub use persistence::{BeginBatch, Persistence, PersistenceBatch};
use regex::Regex;
use reifydb_core::AsyncCowVec;
use reifydb_core::encoding::binary::decode_binary;
use std::ops::{Bound, RangeBounds};
use std::{cmp, result};

mod error;
mod lmdb;
mod memory;
mod persistence;
pub mod test;

pub type Result<T> = result::Result<T, Error>;

pub type Key = AsyncCowVec<u8>;
pub type Value = AsyncCowVec<u8>;

#[derive(Clone, Debug)]
pub struct KeyRange {
    start: Bound<Key>,
    end: Bound<Key>,
}

impl KeyRange {
    /// Generates a key range for a key prefix, used e.g. for prefix scans.
    ///
    /// The exclusive end bound is generated by adding 1 to the value of the last
    /// byte. If the last byte(s) is 0xff (so adding 1 would overflow), we instead
    /// find the latest non-0xff byte, increment that, and truncate the rest. If all
    /// bytes are 0xff, we scan to the end of the range, since there can't be other
    /// prefixes after it.
    pub fn prefix(prefix: &[u8]) -> Self {
        let start = Bound::Included(AsyncCowVec::new(prefix.to_vec()));
        let end = match prefix.iter().rposition(|&b| b != 0xff) {
            Some(i) => Bound::Excluded(AsyncCowVec::new(
                prefix.iter().take(i).copied().chain(std::iter::once(prefix[i] + 1)).collect(),
            )),
            None => Bound::Unbounded,
        };
        Self { start, end }
    }

    /// Constructs a key range from optional start and end prefixes.
    ///
    /// - If `start` is provided, the range starts inclusively at that prefix.
    /// - If `end` is provided, the range ends exclusively just after the prefix,
    ///   handling trailing `0xff` bytes safely by incrementing the last non-`0xff` byte.
    /// - If the `end` consists entirely of `0xff` bytes, the upper bound is unbounded.
    ///
    /// This is useful for lexicographic key scans in ordered key-value stores.
    pub fn start_end(start: Option<Key>, end: Option<Key>) -> Self {
        let start_bound = match start {
            Some(s) => Bound::Included(s),
            None => Bound::Unbounded,
        };

        let end_bound = match end {
            Some(e) => {
                // Handle case where end ends with 0xff to avoid overflow
                if e.iter().all(|&b| b == 0xff) {
                    Bound::Unbounded // cannot go beyond all-0xff
                } else {
                    let mut end = e.to_vec();
                    for i in (0..end.len()).rev() {
                        if end[i] != 0xff {
                            end[i] += 1;
                            end.truncate(i + 1); // discard bytes after the incremented one
                            return Self {
                                start: start_bound,
                                end: Bound::Excluded(AsyncCowVec::new(end)),
                            };
                        }
                    }
                    unreachable!("all-0xff case already handled");
                }
            }
            None => Bound::Unbounded,
        };

        Self { start: start_bound, end: end_bound }
    }

    pub fn all() -> Self {
        Self { start: Bound::Unbounded, end: Bound::Unbounded }
    }

    pub fn parse(str: &str) -> Self {
        let (mut start, mut end) =
            (Bound::<AsyncCowVec<u8>>::Unbounded, Bound::<AsyncCowVec<u8>>::Unbounded);
        let re = Regex::new(r"^(\S+)?\.\.(=)?(\S+)?").expect("invalid regex");
        let groups = re.captures(str).ok_or_else(|| format!("invalid range {str}")).unwrap();
        if let Some(m) = groups.get(1) {
            start = Bound::Included(decode_binary(m.as_str()));
        }
        if let Some(m) = groups.get(3) {
            let decoded = decode_binary(m.as_str());
            if groups.get(2).is_some() {
                end = Bound::Included(decoded)
            } else {
                end = Bound::Excluded(decoded)
            }
        }
        Self { start, end }
    }
}

impl RangeBounds<Key> for KeyRange {
    fn start_bound(&self) -> Bound<&Key> {
        self.start.as_ref()
    }

    fn end_bound(&self) -> Bound<&Key> {
        self.end.as_ref()
    }
}

impl From<(Bound<Key>, Bound<Key>)> for KeyRange {
    fn from(value: (Bound<Key>, Bound<Key>)) -> Self {
        Self { start: value.0, end: value.1 }
    }
}

/// A scan iterator over key-value pairs, returned by [`reifydb_persistence::scan()`].
pub trait ScanIterator: Iterator<Item = Result<(Key, Value)>> {}

impl<T> ScanIterator for T where T: Iterator<Item = Result<(Key, Value)>> {}

/// Operation on a key-value pair.
#[derive(Debug, PartialEq, Eq, Hash)]
pub enum Action {
    Set { key: Key, value: Value },
    Remove { key: Key },
}

impl PartialOrd for Action {
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Action {
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        self.key().cmp(other.key())
    }
}

impl Action {
    /// Returns the key
    pub fn key(&self) -> &Key {
        match self {
            Self::Set { key, .. } => key,
            Self::Remove { key } => key,
        }
    }

    /// Returns the value, if None, it means the entry is marked as remove.
    pub fn value(&self) -> Option<&Value> {
        match self {
            Self::Set { value, .. } => Some(value),
            Self::Remove { .. } => None,
        }
    }
}

impl Clone for Action {
    fn clone(&self) -> Self {
        match self {
            Self::Set { key, value } => Self::Set { key: key.clone(), value: value.clone() },
            Self::Remove { key } => Self::Remove { key: key.clone() },
        }
    }
}
