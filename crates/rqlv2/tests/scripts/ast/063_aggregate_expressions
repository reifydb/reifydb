# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025 ReifyDB

# Test AGGREGATE with arithmetic expression in aggregation
parse 'FROM orders | AGGREGATE { total_value: sum(quantity * price) } BY { product_id }'
---
> Program
> `-- [0] Pipeline
>     +-- [0] From(default.orders)
>     `-- [1] Aggregate
>         +-- group_by:
>         |   `-- [0] Identifier(product_id)
>         `-- aggregations:
>             `-- [0] Binary(KeyValue)
>                 +-- left: Identifier(total_value)
>                 `-- right: Call(sum)
>                     `-- args:
>                         `-- [0] Binary(Mul)
>                             +-- left: Identifier(quantity)
>                             `-- right: Identifier(price)
>

# Test AGGREGATE with nested function calls
parse 'FROM logs | AGGREGATE { rounded_avg: round(avg(duration)) } BY { endpoint }'
---
> Program
> `-- [0] Pipeline
>     +-- [0] From(default.logs)
>     `-- [1] Aggregate
>         +-- group_by:
>         |   `-- [0] Identifier(endpoint)
>         `-- aggregations:
>             `-- [0] Binary(KeyValue)
>                 +-- left: Identifier(rounded_avg)
>                 `-- right: Call(round)
>                     `-- args:
>                         `-- [0] Call(avg)
>                             `-- args:
>                                 `-- [0] Identifier(duration)
>

# Test AGGREGATE with expression in group-by would require explicit expression
parse 'FROM events | AGGREGATE { count: count(id) } BY { category }'
---
> Program
> `-- [0] Pipeline
>     +-- [0] From(default.events)
>     `-- [1] Aggregate
>         +-- group_by:
>         |   `-- [0] Identifier(category)
>         `-- aggregations:
>             `-- [0] Binary(KeyValue)
>                 +-- left: Identifier(count)
>                 `-- right: Call(count)
>                     `-- args:
>                         `-- [0] Identifier(id)
>
