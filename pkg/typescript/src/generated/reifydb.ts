// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: reifydb.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import Long from "long";

export const protobufPackage = "grpc_db";

export enum ValueKind {
  UNDEFINED = 0,
  BOOL = 14,
  FLOAT4 = 1,
  FLOAT8 = 2,
  INT1 = 3,
  INT2 = 4,
  INT4 = 5,
  INT8 = 6,
  INT16 = 7,
  TEXT = 8,
  UINT1 = 9,
  UINT2 = 10,
  UINT4 = 11,
  UINT8 = 12,
  UINT16 = 13,
  UNRECOGNIZED = -1,
}

export function valueKindFromJSON(object: any): ValueKind {
  switch (object) {
    case 0:
    case "UNDEFINED":
      return ValueKind.UNDEFINED;
    case 14:
    case "BOOL":
      return ValueKind.BOOL;
    case 1:
    case "FLOAT4":
      return ValueKind.FLOAT4;
    case 2:
    case "FLOAT8":
      return ValueKind.FLOAT8;
    case 3:
    case "INT1":
      return ValueKind.INT1;
    case 4:
    case "INT2":
      return ValueKind.INT2;
    case 5:
    case "INT4":
      return ValueKind.INT4;
    case 6:
    case "INT8":
      return ValueKind.INT8;
    case 7:
    case "INT16":
      return ValueKind.INT16;
    case 8:
    case "TEXT":
      return ValueKind.TEXT;
    case 9:
    case "UINT1":
      return ValueKind.UINT1;
    case 10:
    case "UINT2":
      return ValueKind.UINT2;
    case 11:
    case "UINT4":
      return ValueKind.UINT4;
    case 12:
    case "UINT8":
      return ValueKind.UINT8;
    case 13:
    case "UINT16":
      return ValueKind.UINT16;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValueKind.UNRECOGNIZED;
  }
}

export function valueKindToJSON(object: ValueKind): string {
  switch (object) {
    case ValueKind.UNDEFINED:
      return "UNDEFINED";
    case ValueKind.BOOL:
      return "BOOL";
    case ValueKind.FLOAT4:
      return "FLOAT4";
    case ValueKind.FLOAT8:
      return "FLOAT8";
    case ValueKind.INT1:
      return "INT1";
    case ValueKind.INT2:
      return "INT2";
    case ValueKind.INT4:
      return "INT4";
    case ValueKind.INT8:
      return "INT8";
    case ValueKind.INT16:
      return "INT16";
    case ValueKind.TEXT:
      return "TEXT";
    case ValueKind.UINT1:
      return "UINT1";
    case ValueKind.UINT2:
      return "UINT2";
    case ValueKind.UINT4:
      return "UINT4";
    case ValueKind.UINT8:
      return "UINT8";
    case ValueKind.UINT16:
      return "UINT16";
    case ValueKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TxRequest {
  query: string;
}

export interface RxRequest {
  query: string;
}

export interface Column {
  name: string;
  value: number;
}

export interface Int128 {
  high: number;
  low: number;
}

export interface UInt128 {
  high: number;
  low: number;
}

export interface Value {
  boolValue?: boolean | undefined;
  int1Value?: number | undefined;
  int2Value?: number | undefined;
  int4Value?: number | undefined;
  int8Value?: number | undefined;
  int16Value?: Int128 | undefined;
  uint1Value?: number | undefined;
  uint2Value?: number | undefined;
  uint4Value?: number | undefined;
  uint8Value?: number | undefined;
  uint16Value?: UInt128 | undefined;
  stringValue?: string | undefined;
  float32Value?: number | undefined;
  float64Value?: number | undefined;
  undefinedValue?: boolean | undefined;
}

export interface Row {
  values: Value[];
}

export interface CreateSchema {
  id: number;
  schema: string;
  created: boolean;
}

export interface CreateSeries {
  schema: string;
  series: string;
}

export interface CreateTable {
  id: number;
  schema: string;
  table: string;
  created: boolean;
}

export interface InsertIntoSeries {
  schema: string;
  series: string;
  inserted: number;
}

export interface InsertIntoTable {
  schema: string;
  table: string;
  inserted: number;
}

export interface QueryResult {
  columns: Column[];
  rows: Row[];
}

export interface DescribeQuery {
  columns: Column[];
}

export interface TxResult {
  createSchema?: CreateSchema | undefined;
  createTable?: CreateTable | undefined;
  insertIntoSeries?: InsertIntoSeries | undefined;
  insertIntoTable?: InsertIntoTable | undefined;
  query?: QueryResult | undefined;
  describeQuery?: DescribeQuery | undefined;
  error?: Diagnostic | undefined;
}

export interface RxResult {
  query?: QueryResult | undefined;
  error?: Diagnostic | undefined;
}

export interface Span {
  offset: number;
  line: number;
  fragment: string;
}

export interface DiagnosticColumn {
  name: string;
  value: ValueKind;
}

export interface Diagnostic {
  code: string;
  message: string;
  span: Span | undefined;
  label: string;
  help: string;
  notes: string[];
  column: DiagnosticColumn | undefined;
}

function createBaseTxRequest(): TxRequest {
  return { query: "" };
}

export const TxRequest = {
  encode(message: TxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: TxRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxRequest>, I>>(base?: I): TxRequest {
    return TxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxRequest>, I>>(object: I): TxRequest {
    const message = createBaseTxRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseRxRequest(): RxRequest {
  return { query: "" };
}

export const RxRequest = {
  encode(message: RxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RxRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: RxRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RxRequest>, I>>(base?: I): RxRequest {
    return RxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RxRequest>, I>>(object: I): RxRequest {
    const message = createBaseRxRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseColumn(): Column {
  return { name: "", value: 0 };
}

export const Column = {
  encode(message: Column, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Column {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Column): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Column>, I>>(base?: I): Column {
    return Column.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Column>, I>>(object: I): Column {
    const message = createBaseColumn();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseInt128(): Int128 {
  return { high: 0, low: 0 };
}

export const Int128 = {
  encode(message: Int128, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.high !== 0) {
      writer.uint32(8).uint64(message.high);
    }
    if (message.low !== 0) {
      writer.uint32(16).uint64(message.low);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Int128 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.high = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.low = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int128 {
    return {
      high: isSet(object.high) ? globalThis.Number(object.high) : 0,
      low: isSet(object.low) ? globalThis.Number(object.low) : 0,
    };
  },

  toJSON(message: Int128): unknown {
    const obj: any = {};
    if (message.high !== 0) {
      obj.high = Math.round(message.high);
    }
    if (message.low !== 0) {
      obj.low = Math.round(message.low);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int128>, I>>(base?: I): Int128 {
    return Int128.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int128>, I>>(object: I): Int128 {
    const message = createBaseInt128();
    message.high = object.high ?? 0;
    message.low = object.low ?? 0;
    return message;
  },
};

function createBaseUInt128(): UInt128 {
  return { high: 0, low: 0 };
}

export const UInt128 = {
  encode(message: UInt128, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.high !== 0) {
      writer.uint32(8).uint64(message.high);
    }
    if (message.low !== 0) {
      writer.uint32(16).uint64(message.low);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UInt128 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.high = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.low = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt128 {
    return {
      high: isSet(object.high) ? globalThis.Number(object.high) : 0,
      low: isSet(object.low) ? globalThis.Number(object.low) : 0,
    };
  },

  toJSON(message: UInt128): unknown {
    const obj: any = {};
    if (message.high !== 0) {
      obj.high = Math.round(message.high);
    }
    if (message.low !== 0) {
      obj.low = Math.round(message.low);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt128>, I>>(base?: I): UInt128 {
    return UInt128.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt128>, I>>(object: I): UInt128 {
    const message = createBaseUInt128();
    message.high = object.high ?? 0;
    message.low = object.low ?? 0;
    return message;
  },
};

function createBaseValue(): Value {
  return {
    boolValue: undefined,
    int1Value: undefined,
    int2Value: undefined,
    int4Value: undefined,
    int8Value: undefined,
    int16Value: undefined,
    uint1Value: undefined,
    uint2Value: undefined,
    uint4Value: undefined,
    uint8Value: undefined,
    uint16Value: undefined,
    stringValue: undefined,
    float32Value: undefined,
    float64Value: undefined,
    undefinedValue: undefined,
  };
}

export const Value = {
  encode(message: Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.boolValue !== undefined) {
      writer.uint32(8).bool(message.boolValue);
    }
    if (message.int1Value !== undefined) {
      writer.uint32(16).int32(message.int1Value);
    }
    if (message.int2Value !== undefined) {
      writer.uint32(24).int32(message.int2Value);
    }
    if (message.int4Value !== undefined) {
      writer.uint32(32).int32(message.int4Value);
    }
    if (message.int8Value !== undefined) {
      writer.uint32(40).int64(message.int8Value);
    }
    if (message.int16Value !== undefined) {
      Int128.encode(message.int16Value, writer.uint32(50).fork()).ldelim();
    }
    if (message.uint1Value !== undefined) {
      writer.uint32(56).uint32(message.uint1Value);
    }
    if (message.uint2Value !== undefined) {
      writer.uint32(64).uint32(message.uint2Value);
    }
    if (message.uint4Value !== undefined) {
      writer.uint32(72).uint32(message.uint4Value);
    }
    if (message.uint8Value !== undefined) {
      writer.uint32(80).uint64(message.uint8Value);
    }
    if (message.uint16Value !== undefined) {
      UInt128.encode(message.uint16Value, writer.uint32(90).fork()).ldelim();
    }
    if (message.stringValue !== undefined) {
      writer.uint32(98).string(message.stringValue);
    }
    if (message.float32Value !== undefined) {
      writer.uint32(109).float(message.float32Value);
    }
    if (message.float64Value !== undefined) {
      writer.uint32(113).double(message.float64Value);
    }
    if (message.undefinedValue !== undefined) {
      writer.uint32(120).bool(message.undefinedValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.int1Value = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.int2Value = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.int4Value = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.int8Value = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.int16Value = Int128.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.uint1Value = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.uint2Value = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.uint4Value = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.uint8Value = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.uint16Value = UInt128.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.float32Value = reader.float();
          continue;
        case 14:
          if (tag !== 113) {
            break;
          }

          message.float64Value = reader.double();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.undefinedValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      int1Value: isSet(object.int1Value) ? globalThis.Number(object.int1Value) : undefined,
      int2Value: isSet(object.int2Value) ? globalThis.Number(object.int2Value) : undefined,
      int4Value: isSet(object.int4Value) ? globalThis.Number(object.int4Value) : undefined,
      int8Value: isSet(object.int8Value) ? globalThis.Number(object.int8Value) : undefined,
      int16Value: isSet(object.int16Value) ? Int128.fromJSON(object.int16Value) : undefined,
      uint1Value: isSet(object.uint1Value) ? globalThis.Number(object.uint1Value) : undefined,
      uint2Value: isSet(object.uint2Value) ? globalThis.Number(object.uint2Value) : undefined,
      uint4Value: isSet(object.uint4Value) ? globalThis.Number(object.uint4Value) : undefined,
      uint8Value: isSet(object.uint8Value) ? globalThis.Number(object.uint8Value) : undefined,
      uint16Value: isSet(object.uint16Value) ? UInt128.fromJSON(object.uint16Value) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      float32Value: isSet(object.float32Value) ? globalThis.Number(object.float32Value) : undefined,
      float64Value: isSet(object.float64Value) ? globalThis.Number(object.float64Value) : undefined,
      undefinedValue: isSet(object.undefinedValue) ? globalThis.Boolean(object.undefinedValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.int1Value !== undefined) {
      obj.int1Value = Math.round(message.int1Value);
    }
    if (message.int2Value !== undefined) {
      obj.int2Value = Math.round(message.int2Value);
    }
    if (message.int4Value !== undefined) {
      obj.int4Value = Math.round(message.int4Value);
    }
    if (message.int8Value !== undefined) {
      obj.int8Value = Math.round(message.int8Value);
    }
    if (message.int16Value !== undefined) {
      obj.int16Value = Int128.toJSON(message.int16Value);
    }
    if (message.uint1Value !== undefined) {
      obj.uint1Value = Math.round(message.uint1Value);
    }
    if (message.uint2Value !== undefined) {
      obj.uint2Value = Math.round(message.uint2Value);
    }
    if (message.uint4Value !== undefined) {
      obj.uint4Value = Math.round(message.uint4Value);
    }
    if (message.uint8Value !== undefined) {
      obj.uint8Value = Math.round(message.uint8Value);
    }
    if (message.uint16Value !== undefined) {
      obj.uint16Value = UInt128.toJSON(message.uint16Value);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.float32Value !== undefined) {
      obj.float32Value = message.float32Value;
    }
    if (message.float64Value !== undefined) {
      obj.float64Value = message.float64Value;
    }
    if (message.undefinedValue !== undefined) {
      obj.undefinedValue = message.undefinedValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.boolValue = object.boolValue ?? undefined;
    message.int1Value = object.int1Value ?? undefined;
    message.int2Value = object.int2Value ?? undefined;
    message.int4Value = object.int4Value ?? undefined;
    message.int8Value = object.int8Value ?? undefined;
    message.int16Value = (object.int16Value !== undefined && object.int16Value !== null)
      ? Int128.fromPartial(object.int16Value)
      : undefined;
    message.uint1Value = object.uint1Value ?? undefined;
    message.uint2Value = object.uint2Value ?? undefined;
    message.uint4Value = object.uint4Value ?? undefined;
    message.uint8Value = object.uint8Value ?? undefined;
    message.uint16Value = (object.uint16Value !== undefined && object.uint16Value !== null)
      ? UInt128.fromPartial(object.uint16Value)
      : undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.float32Value = object.float32Value ?? undefined;
    message.float64Value = object.float64Value ?? undefined;
    message.undefinedValue = object.undefinedValue ?? undefined;
    return message;
  },
};

function createBaseRow(): Row {
  return { values: [] };
}

export const Row = {
  encode(message: Row, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Row {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Row>, I>>(base?: I): Row {
    return Row.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Row>, I>>(object: I): Row {
    const message = createBaseRow();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateSchema(): CreateSchema {
  return { id: 0, schema: "", created: false };
}

export const CreateSchema = {
  encode(message: CreateSchema, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.created !== false) {
      writer.uint32(24).bool(message.created);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSchema {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.created = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSchema {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
    };
  },

  toJSON(message: CreateSchema): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.created !== false) {
      obj.created = message.created;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSchema>, I>>(base?: I): CreateSchema {
    return CreateSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSchema>, I>>(object: I): CreateSchema {
    const message = createBaseCreateSchema();
    message.id = object.id ?? 0;
    message.schema = object.schema ?? "";
    message.created = object.created ?? false;
    return message;
  },
};

function createBaseCreateSeries(): CreateSeries {
  return { schema: "", series: "" };
}

export const CreateSeries = {
  encode(message: CreateSeries, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.series !== "") {
      writer.uint32(18).string(message.series);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSeries {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSeries {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
    };
  },

  toJSON(message: CreateSeries): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSeries>, I>>(base?: I): CreateSeries {
    return CreateSeries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSeries>, I>>(object: I): CreateSeries {
    const message = createBaseCreateSeries();
    message.schema = object.schema ?? "";
    message.series = object.series ?? "";
    return message;
  },
};

function createBaseCreateTable(): CreateTable {
  return { id: 0, schema: "", table: "", created: false };
}

export const CreateTable = {
  encode(message: CreateTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(26).string(message.table);
    }
    if (message.created !== false) {
      writer.uint32(32).bool(message.created);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.table = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.created = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTable {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
    };
  },

  toJSON(message: CreateTable): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.created !== false) {
      obj.created = message.created;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTable>, I>>(base?: I): CreateTable {
    return CreateTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTable>, I>>(object: I): CreateTable {
    const message = createBaseCreateTable();
    message.id = object.id ?? 0;
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    message.created = object.created ?? false;
    return message;
  },
};

function createBaseInsertIntoSeries(): InsertIntoSeries {
  return { schema: "", series: "", inserted: 0 };
}

export const InsertIntoSeries = {
  encode(message: InsertIntoSeries, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.series !== "") {
      writer.uint32(18).string(message.series);
    }
    if (message.inserted !== 0) {
      writer.uint32(24).uint32(message.inserted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertIntoSeries {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertIntoSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inserted = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertIntoSeries {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      inserted: isSet(object.inserted) ? globalThis.Number(object.inserted) : 0,
    };
  },

  toJSON(message: InsertIntoSeries): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.inserted !== 0) {
      obj.inserted = Math.round(message.inserted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertIntoSeries>, I>>(base?: I): InsertIntoSeries {
    return InsertIntoSeries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertIntoSeries>, I>>(object: I): InsertIntoSeries {
    const message = createBaseInsertIntoSeries();
    message.schema = object.schema ?? "";
    message.series = object.series ?? "";
    message.inserted = object.inserted ?? 0;
    return message;
  },
};

function createBaseInsertIntoTable(): InsertIntoTable {
  return { schema: "", table: "", inserted: 0 };
}

export const InsertIntoTable = {
  encode(message: InsertIntoTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(18).string(message.table);
    }
    if (message.inserted !== 0) {
      writer.uint32(24).uint32(message.inserted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertIntoTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertIntoTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.table = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inserted = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertIntoTable {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      inserted: isSet(object.inserted) ? globalThis.Number(object.inserted) : 0,
    };
  },

  toJSON(message: InsertIntoTable): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.inserted !== 0) {
      obj.inserted = Math.round(message.inserted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertIntoTable>, I>>(base?: I): InsertIntoTable {
    return InsertIntoTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertIntoTable>, I>>(object: I): InsertIntoTable {
    const message = createBaseInsertIntoTable();
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    message.inserted = object.inserted ?? 0;
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return { columns: [], rows: [] };
}

export const QueryResult = {
  encode(message: QueryResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.columns) {
      Column.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(Column.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResult {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Column.fromJSON(e)) : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryResult): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Column.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResult>, I>>(base?: I): QueryResult {
    return QueryResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResult>, I>>(object: I): QueryResult {
    const message = createBaseQueryResult();
    message.columns = object.columns?.map((e) => Column.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDescribeQuery(): DescribeQuery {
  return { columns: [] };
}

export const DescribeQuery = {
  encode(message: DescribeQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.columns) {
      Column.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DescribeQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescribeQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(Column.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DescribeQuery {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Column.fromJSON(e)) : [],
    };
  },

  toJSON(message: DescribeQuery): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Column.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DescribeQuery>, I>>(base?: I): DescribeQuery {
    return DescribeQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DescribeQuery>, I>>(object: I): DescribeQuery {
    const message = createBaseDescribeQuery();
    message.columns = object.columns?.map((e) => Column.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTxResult(): TxResult {
  return {
    createSchema: undefined,
    createTable: undefined,
    insertIntoSeries: undefined,
    insertIntoTable: undefined,
    query: undefined,
    describeQuery: undefined,
    error: undefined,
  };
}

export const TxResult = {
  encode(message: TxResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.createSchema !== undefined) {
      CreateSchema.encode(message.createSchema, writer.uint32(10).fork()).ldelim();
    }
    if (message.createTable !== undefined) {
      CreateTable.encode(message.createTable, writer.uint32(18).fork()).ldelim();
    }
    if (message.insertIntoSeries !== undefined) {
      InsertIntoSeries.encode(message.insertIntoSeries, writer.uint32(26).fork()).ldelim();
    }
    if (message.insertIntoTable !== undefined) {
      InsertIntoTable.encode(message.insertIntoTable, writer.uint32(34).fork()).ldelim();
    }
    if (message.query !== undefined) {
      QueryResult.encode(message.query, writer.uint32(42).fork()).ldelim();
    }
    if (message.describeQuery !== undefined) {
      DescribeQuery.encode(message.describeQuery, writer.uint32(50).fork()).ldelim();
    }
    if (message.error !== undefined) {
      Diagnostic.encode(message.error, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TxResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createSchema = CreateSchema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTable = CreateTable.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.insertIntoSeries = InsertIntoSeries.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.insertIntoTable = InsertIntoTable.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query = QueryResult.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.describeQuery = DescribeQuery.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = Diagnostic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxResult {
    return {
      createSchema: isSet(object.createSchema) ? CreateSchema.fromJSON(object.createSchema) : undefined,
      createTable: isSet(object.createTable) ? CreateTable.fromJSON(object.createTable) : undefined,
      insertIntoSeries: isSet(object.insertIntoSeries) ? InsertIntoSeries.fromJSON(object.insertIntoSeries) : undefined,
      insertIntoTable: isSet(object.insertIntoTable) ? InsertIntoTable.fromJSON(object.insertIntoTable) : undefined,
      query: isSet(object.query) ? QueryResult.fromJSON(object.query) : undefined,
      describeQuery: isSet(object.describeQuery) ? DescribeQuery.fromJSON(object.describeQuery) : undefined,
      error: isSet(object.error) ? Diagnostic.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: TxResult): unknown {
    const obj: any = {};
    if (message.createSchema !== undefined) {
      obj.createSchema = CreateSchema.toJSON(message.createSchema);
    }
    if (message.createTable !== undefined) {
      obj.createTable = CreateTable.toJSON(message.createTable);
    }
    if (message.insertIntoSeries !== undefined) {
      obj.insertIntoSeries = InsertIntoSeries.toJSON(message.insertIntoSeries);
    }
    if (message.insertIntoTable !== undefined) {
      obj.insertIntoTable = InsertIntoTable.toJSON(message.insertIntoTable);
    }
    if (message.query !== undefined) {
      obj.query = QueryResult.toJSON(message.query);
    }
    if (message.describeQuery !== undefined) {
      obj.describeQuery = DescribeQuery.toJSON(message.describeQuery);
    }
    if (message.error !== undefined) {
      obj.error = Diagnostic.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxResult>, I>>(base?: I): TxResult {
    return TxResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxResult>, I>>(object: I): TxResult {
    const message = createBaseTxResult();
    message.createSchema = (object.createSchema !== undefined && object.createSchema !== null)
      ? CreateSchema.fromPartial(object.createSchema)
      : undefined;
    message.createTable = (object.createTable !== undefined && object.createTable !== null)
      ? CreateTable.fromPartial(object.createTable)
      : undefined;
    message.insertIntoSeries = (object.insertIntoSeries !== undefined && object.insertIntoSeries !== null)
      ? InsertIntoSeries.fromPartial(object.insertIntoSeries)
      : undefined;
    message.insertIntoTable = (object.insertIntoTable !== undefined && object.insertIntoTable !== null)
      ? InsertIntoTable.fromPartial(object.insertIntoTable)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null)
      ? QueryResult.fromPartial(object.query)
      : undefined;
    message.describeQuery = (object.describeQuery !== undefined && object.describeQuery !== null)
      ? DescribeQuery.fromPartial(object.describeQuery)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Diagnostic.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseRxResult(): RxResult {
  return { query: undefined, error: undefined };
}

export const RxResult = {
  encode(message: RxResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== undefined) {
      QueryResult.encode(message.query, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      Diagnostic.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RxResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRxResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = QueryResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Diagnostic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RxResult {
    return {
      query: isSet(object.query) ? QueryResult.fromJSON(object.query) : undefined,
      error: isSet(object.error) ? Diagnostic.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RxResult): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = QueryResult.toJSON(message.query);
    }
    if (message.error !== undefined) {
      obj.error = Diagnostic.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RxResult>, I>>(base?: I): RxResult {
    return RxResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RxResult>, I>>(object: I): RxResult {
    const message = createBaseRxResult();
    message.query = (object.query !== undefined && object.query !== null)
      ? QueryResult.fromPartial(object.query)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Diagnostic.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseSpan(): Span {
  return { offset: 0, line: 0, fragment: "" };
}

export const Span = {
  encode(message: Span, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offset !== 0) {
      writer.uint32(8).uint32(message.offset);
    }
    if (message.line !== 0) {
      writer.uint32(16).uint32(message.line);
    }
    if (message.fragment !== "") {
      writer.uint32(26).string(message.fragment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Span {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.line = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fragment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span {
    return {
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      fragment: isSet(object.fragment) ? globalThis.String(object.fragment) : "",
    };
  },

  toJSON(message: Span): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.fragment !== "") {
      obj.fragment = message.fragment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span>, I>>(base?: I): Span {
    return Span.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span>, I>>(object: I): Span {
    const message = createBaseSpan();
    message.offset = object.offset ?? 0;
    message.line = object.line ?? 0;
    message.fragment = object.fragment ?? "";
    return message;
  },
};

function createBaseDiagnosticColumn(): DiagnosticColumn {
  return { name: "", value: 0 };
}

export const DiagnosticColumn = {
  encode(message: DiagnosticColumn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiagnosticColumn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnosticColumn {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? valueKindFromJSON(object.value) : 0,
    };
  },

  toJSON(message: DiagnosticColumn): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = valueKindToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticColumn>, I>>(base?: I): DiagnosticColumn {
    return DiagnosticColumn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagnosticColumn>, I>>(object: I): DiagnosticColumn {
    const message = createBaseDiagnosticColumn();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseDiagnostic(): Diagnostic {
  return { code: "", message: "", span: undefined, label: "", help: "", notes: [], column: undefined };
}

export const Diagnostic = {
  encode(message: Diagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.span !== undefined) {
      Span.encode(message.span, writer.uint32(26).fork()).ldelim();
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.help !== "") {
      writer.uint32(42).string(message.help);
    }
    for (const v of message.notes) {
      writer.uint32(50).string(v!);
    }
    if (message.column !== undefined) {
      DiagnosticColumn.encode(message.column, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Diagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.span = Span.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.help = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notes.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.column = DiagnosticColumn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Diagnostic {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      span: isSet(object.span) ? Span.fromJSON(object.span) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      help: isSet(object.help) ? globalThis.String(object.help) : "",
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => globalThis.String(e)) : [],
      column: isSet(object.column) ? DiagnosticColumn.fromJSON(object.column) : undefined,
    };
  },

  toJSON(message: Diagnostic): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.span !== undefined) {
      obj.span = Span.toJSON(message.span);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.help !== "") {
      obj.help = message.help;
    }
    if (message.notes?.length) {
      obj.notes = message.notes;
    }
    if (message.column !== undefined) {
      obj.column = DiagnosticColumn.toJSON(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Diagnostic>, I>>(base?: I): Diagnostic {
    return Diagnostic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Diagnostic>, I>>(object: I): Diagnostic {
    const message = createBaseDiagnostic();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.span = (object.span !== undefined && object.span !== null) ? Span.fromPartial(object.span) : undefined;
    message.label = object.label ?? "";
    message.help = object.help ?? "";
    message.notes = object.notes?.map((e) => e) || [];
    message.column = (object.column !== undefined && object.column !== null)
      ? DiagnosticColumn.fromPartial(object.column)
      : undefined;
    return message;
  },
};

export interface DB {
  Tx(request: TxRequest): Observable<TxResult>;
  Rx(request: RxRequest): Observable<RxResult>;
}

export const DBServiceName = "grpc_db.DB";
export class DBClientImpl implements DB {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DBServiceName;
    this.rpc = rpc;
    this.Tx = this.Tx.bind(this);
    this.Rx = this.Rx.bind(this);
  }
  Tx(request: TxRequest): Observable<TxResult> {
    const data = TxRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Tx", data);
    return result.pipe(map((data) => TxResult.decode(_m0.Reader.create(data))));
  }

  Rx(request: RxRequest): Observable<RxResult> {
    const data = RxRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Rx", data);
    return result.pipe(map((data) => RxResult.decode(_m0.Reader.create(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
